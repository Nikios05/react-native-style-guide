# react-native-style-guide

## Содержание

  1. [Общие правила](#general-rules)
  2. [Именование](#naming)
  3. [Цвет](#colors)
  4. [Типографика](#typography)
  5. [Теги](#tags)
  6. [Графика](#graphics)
  7. [Работа со стилями](#styles)
  
  
## General rules

### Последовательность в коде.
	1. Сначала идут методы, переменные и другой функционал.
	2. Отдельные элементы страницы.
	3. Общий рендер.


### Размещайте стили в отдельном файле
Все стили размещаются в отдельном файле styles.ts в папке с компонентом. Использование инлайновых стилей разрешено только в особенных случаях работы компоннета, реализации логики, подключения шрифтов и цветов. В остальных случаях стоит полностью переносить стили в отдельный файл.

**Bad:**
```ts
<View style={{
	paddingBottom: 5, 
	borderBottomWidth: 1, 
	borderBottomColor: 'red'
	}} 
>
	<Text>Element</Text>
</View>
```

**Good:**

***element.ts***
```ts
<View style={ styles.elementContainer }/>
	<Text>Element</Text>
</View>
```

***styles.ts***
```ts
elementContainer: {
  	paddingBottom: 5, 
	borderBottomWidth: 1, 
	borderBottomColor: 'red'
}
```

### Не бойтесь комментировать
Комментируйте методы, переменные, экспорты и импорты, сложные стили, комметуйте все что может имень двойное значение. Даже если в названии метода все понятно, стоит подумать о том, что происходит внутри и записать это в комментарий. Это поможет не только вам в дальнейшем понимать свой код, но и даст понимание менее опытным разработчикам. 

**Bad:**
```ts
/* Комментарий без подсветки */
piblic foo() {
	...
}
```

**Good:**
```ts
/** Комментарий с подсветкой */
piblic foo() {
	...
}
```

### Одиночные кавычки
Используйте одиночные кавычки для текстовых значений.

**Bad:**
```ts
const text = "Текстовое значение"
```

**Good:**
```ts
const text = 'Текстовое значение'
```

### Проверяйте переполение
При верстке стоит учитывать человеческий фактор и обдумывать какой контент в теории и практике может быть использован на страницы. Для этого можно проверять компонент на переполение с помощью lorem ipsum (гугл в помощь). Это поможет понять где может сломаться верстка и изменить стили так, что бы предусмотреть такое развитие событий.


## Naming

### Называте селекторы правильно
Все селекторы для стилизации элементов имеют стиль написания CamelCase и могут состоять из нескольких слов в зависимости от назначения, система схожая с БЭМ и имеет несколько правил составления имени.
	1. Селектор может состоянить из имени блока, имени элемента и имени модификатора. Пример: answerItemPadding
	2. По возможности стоит сотавлять имя селектора короче, и для блока, элемента или модификатора использовать одно слово.
	3. Имя селектора непосредствнено должно говорить о чем этот блок или элемент.

**Bad:**
```ts
<View style={styles.block}>
	<Icon style={styles.iconLeft} />
	<Text style={styles.text}>Title</Text>
	<Icon style={styles.iconRight} />
</View>
```

**Good:**
```ts
<View style={styles.answerHeader}>
	<Icon style={[styles.answeriIcon, styles.answeriIconLeft]} />
	<Text style={styles.answerTitle}>Title</Text>
	<Icon style={[styles.answeriIcon, styles.answeriIconRight]} />
</View>
```

### Uppercase constants
Все буквы в названии констант используемых для стилизации и верстки имееют верхний регистр.

**Bad:**
```ts
black_22: {
	...
}
```

```ts
blackColor: {
	...
}
```

**Good:**
```ts
BLACK_22: {
	...
}
```


## Colors

### Используйте цветовые константы
Все цвета хранятся в файле constants/colors.ts. Все новые цвета заносятся в этот файл в соответствии с уже созданной логикой.

**Bad:**
```ts
item: {
  backgroundColor: 'rgba(0, 0, 0, 0.22)',
}
```

**Good:**
```ts
item: {
  backgroundColor: COLORS.BLACK_22,
}
```

### Opacity color
Если цвет нельзя реализовать через свойство opacity, но альфа канал необходим, можно использовать хелпер getOpacityColor.

**Bad:**
```ts
<Checkbox 
	...
	checkedColor={ 'rgba(30, 144, 255, 16)' }
	...
/>
```

**Good:**
```ts
<Checkbox 
	...
	checkedColor={ 'rgba(30, 144, 255, 16)' }
	...
/>
```


## Typography

### Используйте шрифты правильно
Все размеры шрифта в файле typography.ts. Все новые размеры заносятся в этот файл в соответствии с уже созданной логикой. По умолчанию шрифт примерно 14/18, поэтому его можно не заводить и не подключать.

**Bad:**

***item.ts***
```ts
<Text style={ styles.textItem }>Lorem ipsum dolor sit amet.</Text>
```

***styles.ts***
```ts
textItem: {
	flex:1,
	fontSize: 22,
	lineHeight: 38
}
```

**Good:**

***typography.ts***
```ts
ACTIVITY_TITLE: {
	fontSize: 22,
	lineHeight: 38
}
```

***item.ts***
```ts
<Text style={ [typography.ACTIVITY_TITLE, styles.textItem] }>
	Lorem ipsum dolor sit amet.
</Text>
```

***styles.ts***
```ts
textItem: {
	flex:1
}
```


## Tags

### Всегда закрывайте теги, у которых нет дочерних элементов

**Bad:**
```ts
<View style={…}></View>
```

**Good:**
```ts
<View style={…} />
```

### Если компонент имеет многострочные свойства, закройте его тег на новой строке

**Bad:**
```ts
<View style={…} 
      bar="bar"
      baz="baz"></View>
```

**Good:**
```ts
<View style={…} 
      bar="bar"
      baz="baz" 
/>
```

### Закрывайте одиночные теги правильно
Всегда включайте один пробел при закрытии одиночного тега

**Bad:**
```ts
<View style={…}/>
```

**Good:**
```ts
<View style={…} />
```


## Graphics

### Для подключения картинок используйте компонент <FitImage>
	

## Styles

### Размешайте стили так как они идут в потоке

```ts
<View style={ styles.list }>
  <View style={ styles.item }>item...</View>
</View>
```

**Bad:**
```ts
item: {
  ...
}, 

list: {
  ...
}
```

**Good:**
```ts
list: {
  ...
}, 

item: {
  ...
}
```

### Ильпользуйте меньше оберток

Если обертка не несет функциональной необходимости, например для разделения или использования стилей, стоит отказаться от нее.

**Bad:**
```ts
<View key={ index }>
  <View style={…}>
	  <Text>text</Text>
  </View>
</View>
```

**Good:**
```ts
<View style={…} key={ index }>
  <Text>text</Text>
</View>
```

### Различайте внешние и внутренние отступы

Внутренний - padding и внешние - margin отступы можно легко взаимозаменять, при этом внешне результат чаще всего будет идентичен. Но это совершенно разные вещи и их нужно различать. Ваш помошник - это дизайн и компонентый подход. Но легче всего запомнить такое правило: padding для элемента, и отталкивания контента от внутренних стенок, а margin, что бы отталкивать элементы друг от друга.

В данном контексте компонент list будет использоваться в других местах и использовать margin не целесообразно, так как необходимо добиться именно внетреннего отспута элементов. А margin в данном случае лучше использовать для отталкивания элементов или отступа всего компонента list.

```ts
<View style={ styles.list }>
  <View style={ styles.item }>...></View>
  <View style={ styles.item }>...</View>
  <View style={ styles.item }>...</View>
</View>
```

**Bad:**
```ts
list: {
  marginVertical: 10,
  marginHorizontal: 10
}
```

**Good:**
```ts
list: {
  paddingVertical: 10,
  paddingHorizontal: 10
  marginBottom: 8
},

item: {
  paddingVertical: 10,
  paddingHorizontal: 10,
  marginBottom: 4
}
```

### Используйте marginBottom
Поток документа в основном идет сверху вниз, и в большинстве случаев лучше использовать marginBottom взаместо marginTop. Это позволяет всегда понимать, что компонент выше, отталкивает от себя нижний, а не наоборот. Но бывают ситуации и обратные. Будьте внимательны и сверяйтесь с дизайном, что бы избежать нежелательных отступов.


### Избегайте отрицательных значений margin
Соблазн быстро решить задачу через отрицательные значения margin велик, но чаще всего в дальнешей перспективе это приносит больше проблем. Так при компонентном подходе, отрицательное значение сыграет злую шутку и элемент уплывет за указанные границы контенера. Несомненно отрицательный margin иногда необходим. В данном случае нужно быть предельно внимательным в рачетах.

```ts
<View style={ styles.list }>
  <View style={ styles.item }>item...</View>
</View>
```

**Bad:**
```ts
list: {
  paddingLeft: 10
},

item: {
  marginLeft: -10
}
```

**Good:**
```ts
list: {
  paddingLeft: 0
}
```
